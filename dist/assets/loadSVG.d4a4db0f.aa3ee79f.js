import{S as bt,af as dt,ah as gt,aj as mt,ax as it,x as L,H as At,b7 as wt,b8 as Tt,b9 as kt,ba as at,A as vt,a9 as lt,bb as ot}from"./index.66975801.js";class ut extends gt{constructor(O){super(O),this.defaultDPI=90,this.defaultUnit="px"}load(O,N,k,j){const A=this,J=new mt(A.manager);J.setPath(A.path),J.setRequestHeader(A.requestHeader),J.setWithCredentials(A.withCredentials),J.load(O,function(et){try{N(A.parse(et))}catch(Q){j?j(Q):console.error(Q),A.manager.itemError(O)}},k,j)}parse(O){const N=this;function k(i,o){if(i.nodeType!==1)return;const t=g(i);let s=!1,a=null;switch(i.nodeName){case"svg":o=q(i,o);break;case"style":A(i);break;case"g":o=q(i,o);break;case"path":o=q(i,o),i.hasAttribute("d")&&(a=j(i));break;case"rect":o=q(i,o),a=Q(i);break;case"polygon":o=q(i,o),a=z(i);break;case"polyline":o=q(i,o),a=_(i);break;case"circle":o=q(i,o),a=V(i);break;case"ellipse":o=q(i,o),a=D(i);break;case"line":o=q(i,o),a=rt(i);break;case"defs":s=!0;break;case"use":o=q(i,o);const r=(i.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),b=i.viewportElement.getElementById(r);b?k(b,o):console.warn("SVGLoader: 'use node' references non-existent node id: "+r);break}a&&(o.fill!==void 0&&o.fill!=="none"&&a.color.setStyle(o.fill),S(a,Z),R.push(a),a.userData={node:i,style:o});const f=i.childNodes;for(let r=0;r<f.length;r++){const b=f[r];s&&b.nodeName!=="style"&&b.nodeName!=="defs"||k(b,o)}t&&(p.pop(),p.length>0?Z.copy(p[p.length-1]):Z.identity())}function j(i){const o=new ot,t=new L,s=new L,a=new L;let f=!0,r=!1;const b=i.getAttribute("d").match(/[a-df-z][^a-df-z]*/ig);for(let x=0,h=b.length;x<h;x++){const M=b[x],B=M.charAt(0),v=M.slice(1).trim();f===!0&&(r=!0,f=!1);let n;switch(B){case"M":n=u(v);for(let e=0,c=n.length;e<c;e+=2)t.x=n[e+0],t.y=n[e+1],s.x=t.x,s.y=t.y,e===0?o.moveTo(t.x,t.y):o.lineTo(t.x,t.y),e===0&&a.copy(t);break;case"H":n=u(v);for(let e=0,c=n.length;e<c;e++)t.x=n[e],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"V":n=u(v);for(let e=0,c=n.length;e<c;e++)t.y=n[e],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"L":n=u(v);for(let e=0,c=n.length;e<c;e+=2)t.x=n[e+0],t.y=n[e+1],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"C":n=u(v);for(let e=0,c=n.length;e<c;e+=6)o.bezierCurveTo(n[e+0],n[e+1],n[e+2],n[e+3],n[e+4],n[e+5]),s.x=n[e+2],s.y=n[e+3],t.x=n[e+4],t.y=n[e+5],e===0&&r===!0&&a.copy(t);break;case"S":n=u(v);for(let e=0,c=n.length;e<c;e+=4)o.bezierCurveTo(d(t.x,s.x),d(t.y,s.y),n[e+0],n[e+1],n[e+2],n[e+3]),s.x=n[e+0],s.y=n[e+1],t.x=n[e+2],t.y=n[e+3],e===0&&r===!0&&a.copy(t);break;case"Q":n=u(v);for(let e=0,c=n.length;e<c;e+=4)o.quadraticCurveTo(n[e+0],n[e+1],n[e+2],n[e+3]),s.x=n[e+0],s.y=n[e+1],t.x=n[e+2],t.y=n[e+3],e===0&&r===!0&&a.copy(t);break;case"T":n=u(v);for(let e=0,c=n.length;e<c;e+=2){const P=d(t.x,s.x),G=d(t.y,s.y);o.quadraticCurveTo(P,G,n[e+0],n[e+1]),s.x=P,s.y=G,t.x=n[e+0],t.y=n[e+1],e===0&&r===!0&&a.copy(t)}break;case"A":n=u(v,[3,4],7);for(let e=0,c=n.length;e<c;e+=7){if(n[e+5]==t.x&&n[e+6]==t.y)continue;const P=t.clone();t.x=n[e+5],t.y=n[e+6],s.x=t.x,s.y=t.y,J(o,n[e],n[e+1],n[e+2],n[e+3],n[e+4],P,t),e===0&&r===!0&&a.copy(t)}break;case"m":n=u(v);for(let e=0,c=n.length;e<c;e+=2)t.x+=n[e+0],t.y+=n[e+1],s.x=t.x,s.y=t.y,e===0?o.moveTo(t.x,t.y):o.lineTo(t.x,t.y),e===0&&a.copy(t);break;case"h":n=u(v);for(let e=0,c=n.length;e<c;e++)t.x+=n[e],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"v":n=u(v);for(let e=0,c=n.length;e<c;e++)t.y+=n[e],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"l":n=u(v);for(let e=0,c=n.length;e<c;e+=2)t.x+=n[e+0],t.y+=n[e+1],s.x=t.x,s.y=t.y,o.lineTo(t.x,t.y),e===0&&r===!0&&a.copy(t);break;case"c":n=u(v);for(let e=0,c=n.length;e<c;e+=6)o.bezierCurveTo(t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3],t.x+n[e+4],t.y+n[e+5]),s.x=t.x+n[e+2],s.y=t.y+n[e+3],t.x+=n[e+4],t.y+=n[e+5],e===0&&r===!0&&a.copy(t);break;case"s":n=u(v);for(let e=0,c=n.length;e<c;e+=4)o.bezierCurveTo(d(t.x,s.x),d(t.y,s.y),t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3]),s.x=t.x+n[e+0],s.y=t.y+n[e+1],t.x+=n[e+2],t.y+=n[e+3],e===0&&r===!0&&a.copy(t);break;case"q":n=u(v);for(let e=0,c=n.length;e<c;e+=4)o.quadraticCurveTo(t.x+n[e+0],t.y+n[e+1],t.x+n[e+2],t.y+n[e+3]),s.x=t.x+n[e+0],s.y=t.y+n[e+1],t.x+=n[e+2],t.y+=n[e+3],e===0&&r===!0&&a.copy(t);break;case"t":n=u(v);for(let e=0,c=n.length;e<c;e+=2){const P=d(t.x,s.x),G=d(t.y,s.y);o.quadraticCurveTo(P,G,t.x+n[e+0],t.y+n[e+1]),s.x=P,s.y=G,t.x=t.x+n[e+0],t.y=t.y+n[e+1],e===0&&r===!0&&a.copy(t)}break;case"a":n=u(v,[3,4],7);for(let e=0,c=n.length;e<c;e+=7){if(n[e+5]==0&&n[e+6]==0)continue;const P=t.clone();t.x+=n[e+5],t.y+=n[e+6],s.x=t.x,s.y=t.y,J(o,n[e],n[e+1],n[e+2],n[e+3],n[e+4],P,t),e===0&&r===!0&&a.copy(t)}break;case"Z":case"z":o.currentPath.autoClose=!0,o.currentPath.curves.length>0&&(t.copy(a),o.currentPath.currentPoint.copy(t),f=!0);break;default:console.warn(M)}r=!1}return o}function A(i){if(!(!i.sheet||!i.sheet.cssRules||!i.sheet.cssRules.length))for(let o=0;o<i.sheet.cssRules.length;o++){const t=i.sheet.cssRules[o];if(t.type!==1)continue;const s=t.selectorText.split(/,/gm).filter(Boolean).map(a=>a.trim());for(let a=0;a<s.length;a++){const f=Object.fromEntries(Object.entries(t.style).filter(([,r])=>r!==""));X[s[a]]=Object.assign(X[s[a]]||{},f)}}}function J(i,o,t,s,a,f,r,b){if(o==0||t==0){i.lineTo(b.x,b.y);return}s=s*Math.PI/180,o=Math.abs(o),t=Math.abs(t);const x=(r.x-b.x)/2,h=(r.y-b.y)/2,M=Math.cos(s)*x+Math.sin(s)*h,B=-Math.sin(s)*x+Math.cos(s)*h;let v=o*o,n=t*t;const e=M*M,c=B*B,P=e/v+c/n;if(P>1){const ht=Math.sqrt(P);o=ht*o,t=ht*t,v=o*o,n=t*t}const G=v*c+n*e,nt=(v*n-G)/G;let F=Math.sqrt(Math.max(0,nt));a===f&&(F=-F);const $=F*o*B/t,st=-F*t*M/o,ft=Math.cos(s)*$-Math.sin(s)*st+(r.x+b.x)/2,pt=Math.sin(s)*$+Math.cos(s)*st+(r.y+b.y)/2,yt=et(1,0,(M-$)/o,(B-st)/t),xt=et((M-$)/o,(B-st)/t,(-M-$)/o,(-B-st)/t)%(Math.PI*2);i.currentPath.absellipse(ft,pt,o,t,yt,yt+xt,f===0,s)}function et(i,o,t,s){const a=i*t+o*s,f=Math.sqrt(i*i+o*o)*Math.sqrt(t*t+s*s);let r=Math.acos(Math.max(-1,Math.min(1,a/f)));return i*s-o*t<0&&(r=-r),r}function Q(i){const o=y(i.getAttribute("x")||0),t=y(i.getAttribute("y")||0),s=y(i.getAttribute("rx")||i.getAttribute("ry")||0),a=y(i.getAttribute("ry")||i.getAttribute("rx")||0),f=y(i.getAttribute("width")),r=y(i.getAttribute("height")),b=1-.551915024494,x=new ot;return x.moveTo(o+s,t),x.lineTo(o+f-s,t),(s!==0||a!==0)&&x.bezierCurveTo(o+f-s*b,t,o+f,t+a*b,o+f,t+a),x.lineTo(o+f,t+r-a),(s!==0||a!==0)&&x.bezierCurveTo(o+f,t+r-a*b,o+f-s*b,t+r,o+f-s,t+r),x.lineTo(o+s,t+r),(s!==0||a!==0)&&x.bezierCurveTo(o+s*b,t+r,o,t+r-a*b,o,t+r-a),x.lineTo(o,t+a),(s!==0||a!==0)&&x.bezierCurveTo(o,t+a*b,o+s*b,t,o+s,t),x}function z(i){function o(f,r,b){const x=y(r),h=y(b);a===0?s.moveTo(x,h):s.lineTo(x,h),a++}const t=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,s=new ot;let a=0;return i.getAttribute("points").replace(t,o),s.currentPath.autoClose=!0,s}function _(i){function o(f,r,b){const x=y(r),h=y(b);a===0?s.moveTo(x,h):s.lineTo(x,h),a++}const t=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,s=new ot;let a=0;return i.getAttribute("points").replace(t,o),s.currentPath.autoClose=!1,s}function V(i){const o=y(i.getAttribute("cx")||0),t=y(i.getAttribute("cy")||0),s=y(i.getAttribute("r")||0),a=new at;a.absarc(o,t,s,0,Math.PI*2);const f=new ot;return f.subPaths.push(a),f}function D(i){const o=y(i.getAttribute("cx")||0),t=y(i.getAttribute("cy")||0),s=y(i.getAttribute("rx")||0),a=y(i.getAttribute("ry")||0),f=new at;f.absellipse(o,t,s,a,0,Math.PI*2);const r=new ot;return r.subPaths.push(f),r}function rt(i){const o=y(i.getAttribute("x1")||0),t=y(i.getAttribute("y1")||0),s=y(i.getAttribute("x2")||0),a=y(i.getAttribute("y2")||0),f=new ot;return f.moveTo(o,t),f.lineTo(s,a),f.currentPath.autoClose=!1,f}function q(i,o){o=Object.assign({},o);let t={};if(i.hasAttribute("class")){const r=i.getAttribute("class").split(/\s/).filter(Boolean).map(b=>b.trim());for(let b=0;b<r.length;b++)t=Object.assign(t,X["."+r[b]])}i.hasAttribute("id")&&(t=Object.assign(t,X["#"+i.getAttribute("id")]));function s(r,b,x){x===void 0&&(x=function(h){return h.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),h}),i.hasAttribute(r)&&(o[b]=x(i.getAttribute(r))),t[r]&&(o[b]=x(t[r])),i.style&&i.style[r]!==""&&(o[b]=x(i.style[r]))}function a(r){return Math.max(0,Math.min(1,y(r)))}function f(r){return Math.max(0,y(r))}return s("fill","fill"),s("fill-opacity","fillOpacity",a),s("fill-rule","fillRule"),s("opacity","opacity",a),s("stroke","stroke"),s("stroke-opacity","strokeOpacity",a),s("stroke-width","strokeWidth",f),s("stroke-linejoin","strokeLineJoin"),s("stroke-linecap","strokeLineCap"),s("stroke-miterlimit","strokeMiterLimit",f),s("visibility","visibility"),o}function d(i,o){return i-(o-i)}function u(i,o,t){if(typeof i!="string")throw new TypeError("Invalid input: "+typeof i);const s={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},a=0,f=1,r=2,b=3;let x=a,h=!0,M="",B="";const v=[];function n(G,nt,F){const $=new SyntaxError('Unexpected character "'+G+'" at index '+nt+".");throw $.partial=F,$}function e(){M!==""&&(B===""?v.push(Number(M)):v.push(Number(M)*Math.pow(10,Number(B)))),M="",B=""}let c;const P=i.length;for(let G=0;G<P;G++){if(c=i[G],Array.isArray(o)&&o.includes(v.length%t)&&s.FLAGS.test(c)){x=f,M=c,e();continue}if(x===a){if(s.WHITESPACE.test(c))continue;if(s.DIGIT.test(c)||s.SIGN.test(c)){x=f,M=c;continue}if(s.POINT.test(c)){x=r,M=c;continue}s.COMMA.test(c)&&(h&&n(c,G,v),h=!0)}if(x===f){if(s.DIGIT.test(c)){M+=c;continue}if(s.POINT.test(c)){M+=c,x=r;continue}if(s.EXP.test(c)){x=b;continue}s.SIGN.test(c)&&M.length===1&&s.SIGN.test(M[0])&&n(c,G,v)}if(x===r){if(s.DIGIT.test(c)){M+=c;continue}if(s.EXP.test(c)){x=b;continue}s.POINT.test(c)&&M[M.length-1]==="."&&n(c,G,v)}if(x===b){if(s.DIGIT.test(c)){B+=c;continue}if(s.SIGN.test(c)){if(B===""){B+=c;continue}B.length===1&&s.SIGN.test(B)&&n(c,G,v)}}s.WHITESPACE.test(c)?(e(),x=a,h=!1):s.COMMA.test(c)?(e(),x=a,h=!0):s.SIGN.test(c)?(e(),x=f,M=c):s.POINT.test(c)?(e(),x=r,M=c):n(c,G,v)}return e(),v}const m=["mm","cm","in","pt","pc","px"],I={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function y(i){let o="px";if(typeof i=="string"||i instanceof String)for(let s=0,a=m.length;s<a;s++){const f=m[s];if(i.endsWith(f)){o=f,i=i.substring(0,i.length-f.length);break}}let t;return o==="px"&&N.defaultUnit!=="px"?t=I.in[N.defaultUnit]/N.defaultDPI:(t=I[o][N.defaultUnit],t<0&&(t=I[o].in*N.defaultDPI)),t*parseFloat(i)}function g(i){if(!(i.hasAttribute("transform")||i.nodeName==="use"&&(i.hasAttribute("x")||i.hasAttribute("y"))))return null;const o=w(i);return p.length>0&&o.premultiply(p[p.length-1]),Z.copy(o),p.push(o),o}function w(i){const o=new it,t=Y;if(i.nodeName==="use"&&(i.hasAttribute("x")||i.hasAttribute("y"))){const s=y(i.getAttribute("x")),a=y(i.getAttribute("y"));o.translate(s,a)}if(i.hasAttribute("transform")){const s=i.getAttribute("transform").split(")");for(let a=s.length-1;a>=0;a--){const f=s[a].trim();if(f==="")continue;const r=f.indexOf("("),b=f.length;if(r>0&&r<b){const x=f.slice(0,r),h=u(f.slice(r+1));switch(t.identity(),x){case"translate":if(h.length>=1){const M=h[0];let B=0;h.length>=2&&(B=h[1]),t.translate(M,B)}break;case"rotate":if(h.length>=1){let M=0,B=0,v=0;M=-h[0]*Math.PI/180,h.length>=3&&(B=h[1],v=h[2]),H.identity().translate(-B,-v),tt.identity().rotate(M),K.multiplyMatrices(tt,H),H.identity().translate(B,v),t.multiplyMatrices(H,K)}break;case"scale":if(h.length>=1){const M=h[0];let B=M;h.length>=2&&(B=h[1]),t.scale(M,B)}break;case"skewX":h.length===1&&t.set(1,Math.tan(h[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":h.length===1&&t.set(1,0,0,Math.tan(h[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":h.length===6&&t.set(h[0],h[2],h[4],h[1],h[3],h[5],0,0,1);break}}o.premultiply(t)}}return o}function S(i,o){function t(f){l.set(f.x,f.y,1).applyMatrix3(o),f.set(l.x,l.y)}const s=W(o),a=i.subPaths;for(let f=0,r=a.length;f<r;f++){const b=a[f].curves;for(let x=0;x<b.length;x++){const h=b[x];h.isLineCurve?(t(h.v1),t(h.v2)):h.isCubicBezierCurve?(t(h.v0),t(h.v1),t(h.v2),t(h.v3)):h.isQuadraticBezierCurve?(t(h.v0),t(h.v1),t(h.v2)):h.isEllipseCurve&&(s&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),T.set(h.aX,h.aY),t(T),h.aX=T.x,h.aY=T.y,h.xRadius*=C(o),h.yRadius*=E(o))}}}function W(i){return i.elements[1]!==0||i.elements[3]!==0}function C(i){const o=i.elements;return Math.sqrt(o[0]*o[0]+o[1]*o[1])}function E(i){const o=i.elements;return Math.sqrt(o[3]*o[3]+o[4]*o[4])}const R=[],X={},p=[],Y=new it,H=new it,tt=new it,K=new it,T=new L,l=new At,Z=new it,U=new DOMParser().parseFromString(O,"image/svg+xml");return k(U.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:R,xml:U.documentElement}}static createShapes(O){const N={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},k={loc:N.ORIGIN,t:0};function j(d,u,m,I){const y=d.x,g=u.x,w=m.x,S=I.x,W=d.y,C=u.y,E=m.y,R=I.y,X=(S-w)*(W-E)-(R-E)*(y-w),p=(g-y)*(W-E)-(C-W)*(y-w),Y=(R-E)*(g-y)-(S-w)*(C-W),H=X/Y,tt=p/Y;if(Y===0&&X!==0||H<=0||H>=1||tt<0||tt>1)return null;if(X===0&&Y===0){for(let K=0;K<2;K++)if(A(K===0?m:I,d,u),k.loc==N.ORIGIN){const T=K===0?m:I;return{x:T.x,y:T.y,t:k.t}}else if(k.loc==N.BETWEEN){const T=+(y+k.t*(g-y)).toPrecision(10),l=+(W+k.t*(C-W)).toPrecision(10);return{x:T,y:l,t:k.t}}return null}else{for(let l=0;l<2;l++)if(A(l===0?m:I,d,u),k.loc==N.ORIGIN){const Z=l===0?m:I;return{x:Z.x,y:Z.y,t:k.t}}const K=+(y+H*(g-y)).toPrecision(10),T=+(W+H*(C-W)).toPrecision(10);return{x:K,y:T,t:H}}}function A(d,u,m){const I=m.x-u.x,y=m.y-u.y,g=d.x-u.x,w=d.y-u.y,S=I*w-g*y;if(d.x===u.x&&d.y===u.y){k.loc=N.ORIGIN,k.t=0;return}if(d.x===m.x&&d.y===m.y){k.loc=N.DESTINATION,k.t=1;return}if(S<-Number.EPSILON){k.loc=N.LEFT;return}if(S>Number.EPSILON){k.loc=N.RIGHT;return}if(I*g<0||y*w<0){k.loc=N.BEHIND;return}if(Math.sqrt(I*I+y*y)<Math.sqrt(g*g+w*w)){k.loc=N.BEYOND;return}let W;I!==0?W=g/I:W=w/y,k.loc=N.BETWEEN,k.t=W}function J(d,u){const m=[],I=[];for(let y=1;y<d.length;y++){const g=d[y-1],w=d[y];for(let S=1;S<u.length;S++){const W=u[S-1],C=u[S],E=j(g,w,W,C);E!==null&&m.find(R=>R.t<=E.t+Number.EPSILON&&R.t>=E.t-Number.EPSILON)===void 0&&(m.push(E),I.push(new L(E.x,E.y)))}}return I}function et(d,u,m){const I=new L;u.getCenter(I);const y=[];return m.forEach(g=>{g.boundingBox.containsPoint(I)&&J(d,g.points).forEach(w=>{y.push({identifier:g.identifier,isCW:g.isCW,point:w})})}),y.sort((g,w)=>g.point.x-w.point.x),y}function Q(d,u,m,I,y){(y==null||y==="")&&(y="nonzero");const g=new L;d.boundingBox.getCenter(g);const w=[new L(m,g.y),new L(I,g.y)],S=et(w,d.boundingBox,u);S.sort((p,Y)=>p.point.x-Y.point.x);const W=[],C=[];S.forEach(p=>{p.identifier===d.identifier?W.push(p):C.push(p)});const E=W[0].point.x,R=[];let X=0;for(;X<C.length&&C[X].point.x<E;)R.length>0&&R[R.length-1]===C[X].identifier?R.pop():R.push(C[X].identifier),X++;if(R.push(d.identifier),y==="evenodd"){const p=R.length%2===0,Y=R[R.length-2];return{identifier:d.identifier,isHole:p,for:Y}}else if(y==="nonzero"){let p=!0,Y=null,H=null;for(let tt=0;tt<R.length;tt++){const K=R[tt];p?(H=u[K].isCW,p=!1,Y=K):H!==u[K].isCW&&(H=u[K].isCW,p=!0)}return{identifier:d.identifier,isHole:p,for:Y}}else console.warn('fill-rule: "'+y+'" is currently not implemented.')}let z=0,_=999999999,V=-999999999,D=O.subPaths.map(d=>{const u=d.getPoints();let m=-999999999,I=999999999,y=-999999999,g=999999999;for(let w=0;w<u.length;w++){const S=u[w];S.y>m&&(m=S.y),S.y<I&&(I=S.y),S.x>y&&(y=S.x),S.x<g&&(g=S.x)}return V<=y&&(V=y+1),_>=g&&(_=g-1),{curves:d.curves,points:u,isCW:wt.isClockWise(u),identifier:z++,boundingBox:new Tt(new L(g,I),new L(y,m))}});D=D.filter(d=>d.points.length>1);const rt=D.map(d=>{var u;return Q(d,D,_,V,(u=O.userData)==null?void 0:u.style.fillRule)}),q=[];return D.forEach(d=>{if(!rt[d.identifier].isHole){const u=new kt;u.curves=d.curves,rt.filter(m=>m.isHole&&m.for===d.identifier).forEach(m=>{const I=D[m.identifier],y=new at;y.curves=I.curves,u.holes.push(y)}),q.push(u)}}),q}static getStrokeStyle(O,N,k,j,A){return O=O!==void 0?O:1,N=N!==void 0?N:"#000",k=k!==void 0?k:"miter",j=j!==void 0?j:"butt",A=A!==void 0?A:4,{strokeColor:N,strokeWidth:O,strokeLineJoin:k,strokeLineCap:j,strokeMiterLimit:A}}static pointsToStroke(O,N,k,j){const A=[],J=[],et=[];if(ut.pointsToStrokeWithBuffers(O,N,k,j,A,J,et)===0)return null;const Q=new vt;return Q.setAttribute("position",new lt(A,3)),Q.setAttribute("normal",new lt(J,3)),Q.setAttribute("uv",new lt(et,2)),Q}static pointsToStrokeWithBuffers(O,N,k,j,A,J,et,Q){const z=new L,_=new L,V=new L,D=new L,rt=new L,q=new L,d=new L,u=new L,m=new L,I=new L,y=new L,g=new L,w=new L,S=new L,W=new L,C=new L,E=new L;k=k!==void 0?k:12,j=j!==void 0?j:.001,Q=Q!==void 0?Q:0,O=v(O);const R=O.length;if(R<2)return 0;const X=O[0].equals(O[R-1]);let p,Y=O[0],H;const tt=N.strokeWidth/2,K=1/(R-1);let T=0,l,Z,U,i,o=!1,t=0,s=Q*3,a=Q*2;f(O[0],O[1],z).multiplyScalar(tt),u.copy(O[0]).sub(z),m.copy(O[0]).add(z),I.copy(u),y.copy(m);for(let n=1;n<R;n++){p=O[n],n===R-1?X?H=O[1]:H=void 0:H=O[n+1];const e=z;if(f(Y,p,e),V.copy(e).multiplyScalar(tt),g.copy(p).sub(V),w.copy(p).add(V),l=T+K,Z=!1,H!==void 0){f(p,H,_),V.copy(_).multiplyScalar(tt),S.copy(p).sub(V),W.copy(p).add(V),U=!0,V.subVectors(H,Y),e.dot(V)<0&&(U=!1),n===1&&(o=U),V.subVectors(H,p),V.normalize();const c=Math.abs(e.dot(V));if(c>Number.EPSILON){const P=tt/c;V.multiplyScalar(-P),D.subVectors(p,Y),rt.copy(D).setLength(P).add(V),C.copy(rt).negate();const G=rt.length(),nt=D.length();D.divideScalar(nt),q.subVectors(H,p);const F=q.length();switch(q.divideScalar(F),D.dot(C)<nt&&q.dot(C)<F&&(Z=!0),E.copy(rt).add(p),C.add(p),i=!1,Z?U?(W.copy(C),w.copy(C)):(S.copy(C),g.copy(C)):x(),N.strokeLineJoin){case"bevel":h(U,Z,l);break;case"round":M(U,Z),U?b(p,g,S,l,0):b(p,W,w,l,1);break;case"miter":case"miter-clip":default:const $=tt*N.strokeMiterLimit/G;if($<1)if(N.strokeLineJoin!=="miter-clip"){h(U,Z,l);break}else M(U,Z),U?(q.subVectors(E,g).multiplyScalar($).add(g),d.subVectors(E,S).multiplyScalar($).add(S),r(g,l,0),r(q,l,0),r(p,l,.5),r(p,l,.5),r(q,l,0),r(d,l,0),r(p,l,.5),r(d,l,0),r(S,l,0)):(q.subVectors(E,w).multiplyScalar($).add(w),d.subVectors(E,W).multiplyScalar($).add(W),r(w,l,1),r(q,l,1),r(p,l,.5),r(p,l,.5),r(q,l,1),r(d,l,1),r(p,l,.5),r(d,l,1),r(W,l,1));else Z?(U?(r(m,T,1),r(u,T,0),r(E,l,0),r(m,T,1),r(E,l,0),r(C,l,1)):(r(m,T,1),r(u,T,0),r(E,l,1),r(u,T,0),r(C,l,0),r(E,l,1)),U?S.copy(E):W.copy(E)):U?(r(g,l,0),r(E,l,0),r(p,l,.5),r(p,l,.5),r(E,l,0),r(S,l,0)):(r(w,l,1),r(E,l,1),r(p,l,.5),r(p,l,.5),r(E,l,1),r(W,l,1)),i=!0;break}}else x()}else x();!X&&n===R-1&&B(O[0],I,y,U,!0,T),T=l,Y=p,u.copy(S),m.copy(W)}if(!X)B(p,g,w,U,!1,l);else if(Z&&A){let n=E,e=C;o!==U&&(n=C,e=E),U?(i||o)&&(e.toArray(A,0*3),e.toArray(A,3*3),i&&n.toArray(A,1*3)):(i||!o)&&(e.toArray(A,1*3),e.toArray(A,3*3),i&&n.toArray(A,0*3))}return t;function f(n,e,c){return c.subVectors(e,n),c.set(-c.y,c.x).normalize()}function r(n,e,c){A&&(A[s]=n.x,A[s+1]=n.y,A[s+2]=0,J&&(J[s]=0,J[s+1]=0,J[s+2]=1),s+=3,et&&(et[a]=e,et[a+1]=c,a+=2)),t+=3}function b(n,e,c,P,G){z.copy(e).sub(n).normalize(),_.copy(c).sub(n).normalize();let nt=Math.PI;const F=z.dot(_);Math.abs(F)<1&&(nt=Math.abs(Math.acos(F))),nt/=k,V.copy(e);for(let $=0,st=k-1;$<st;$++)D.copy(V).rotateAround(n,nt),r(V,P,G),r(D,P,G),r(n,P,.5),V.copy(D);r(D,P,G),r(c,P,G),r(n,P,.5)}function x(){r(m,T,1),r(u,T,0),r(g,l,0),r(m,T,1),r(g,l,1),r(w,l,0)}function h(n,e,c){e?n?(r(m,T,1),r(u,T,0),r(g,l,0),r(m,T,1),r(g,l,0),r(C,l,1),r(g,c,0),r(S,c,0),r(C,c,.5)):(r(m,T,1),r(u,T,0),r(w,l,1),r(u,T,0),r(C,l,0),r(w,l,1),r(w,c,1),r(W,c,0),r(C,c,.5)):n?(r(g,c,0),r(S,c,0),r(p,c,.5)):(r(w,c,1),r(W,c,0),r(p,c,.5))}function M(n,e){e&&(n?(r(m,T,1),r(u,T,0),r(g,l,0),r(m,T,1),r(g,l,0),r(C,l,1),r(g,T,0),r(p,l,.5),r(C,l,1),r(p,l,.5),r(S,T,0),r(C,l,1)):(r(m,T,1),r(u,T,0),r(w,l,1),r(u,T,0),r(C,l,0),r(w,l,1),r(w,T,1),r(C,l,0),r(p,l,.5),r(p,l,.5),r(C,l,0),r(W,T,1)))}function B(n,e,c,P,G,nt){switch(N.strokeLineCap){case"round":G?b(n,c,e,nt,.5):b(n,e,c,nt,.5);break;case"square":if(G)z.subVectors(e,n),_.set(z.y,-z.x),V.addVectors(z,_).add(n),D.subVectors(_,z).add(n),P?(V.toArray(A,1*3),D.toArray(A,0*3),D.toArray(A,3*3)):(V.toArray(A,1*3),V.toArray(A,3*3),D.toArray(A,0*3));else{z.subVectors(c,n),_.set(z.y,-z.x),V.addVectors(z,_).add(n),D.subVectors(_,z).add(n);const F=A.length;P?(V.toArray(A,F-1*3),D.toArray(A,F-2*3),D.toArray(A,F-4*3)):(V.toArray(A,F-2*3),D.toArray(A,F-1*3),D.toArray(A,F-4*3))}break}}function v(n){let e=!1;for(let P=1,G=n.length-1;P<G;P++)if(n[P].distanceTo(n[P+1])<j){e=!0;break}if(!e)return n;const c=[];c.push(n[0]);for(let P=1,G=n.length-1;P<G;P++)n[P].distanceTo(n[P+1])>=j&&c.push(n[P]);return c.push(n[n.length-1]),c}}}const Mt=new Map,Pt=new ut,Ct=ct=>bt(Mt,ct,()=>new Promise((O,N)=>{Pt.load(ct,k=>O(Object.freeze(k)),dt(ct),N)}));export{Ct as default};
